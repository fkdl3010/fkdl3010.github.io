[ { "title": "동시성 제어", "url": "/posts/%EB%B3%91%ED%96%89%EC%A0%9C%EC%96%B4/", "categories": "DataBase", "tags": "DataBase", "date": "2021-12-27 00:00:00 +0900", "snippet": "동시성 제어(concurrency control)란?다중 사용자 환경을 지원하는 데이터베이스 시스템에서 여러 트랜잭션들이 성공적으로 동시에 실행 될 수 있도록 지원하는 기능입니다. 이를 동시성제어 또는 병행제어 라고도 합니다.동시성 제어의 필요성트랜잭션이 순차적으로, 즉 시간이 겹치지 않고 순차적으로 실행된다면 동시성이 존재하지 않습니다. 하지만 다수의 사용자가 접근하는 DB의 경우 여러 트랜잭션이 하나의 데이터를 삽입, 갱신, 삭제 등의 작업을 동시에 수행하게 될 때 동시성 제어가 적절하게 설계되어있지 않다면 예기치 못한 문제점들이 발생할 수 있습니다.동시성 제어를 하지 않는 경우 문제점I. Dirty Write갱신 분실(Lost Update)이라고도 합니다. 두 개의 서로 다른 트랜잭션이 데이터베이스 내의 동일한 행에 있는 동일한 열을 동시에 업데이트하려고 할 때 발생 T1 이 id가 1인 user를 조회 T2 도 id가 1인 user를 조회 T1 이 id가 1인 user의 age를 업데이트 후 커밋 T2 도 id가 1인 user의 age를 업데이트 후 커밋문제점 일반적으로 한 트랜잭션은 특정 행, 특정 열을 업데이트하는 반면, 얼마 후에 시작된 다른 트랜잭션은 동일한 값 자체를 업데이트하기 전에 이 업데이트를 인지하지 못함 첫 번째 트랜잭션의 결과가 두 번째 트랜잭션에 의해 덮어 쓰기되므로 lost 발생 II. Dirty Read비완료 의존성(Uncommitted Dependency)이라고도 *합니다.* 아직 commit되지 않은 트랜잭션의 내용을 읽으려고 함문제점 T1에서 update를 진행하였으나 commit을 하지않음 T2에서 age를 20으로 read T1에서 rollback 진행 → 하지만 T2는 age를 여전히 20으로 알고있음III. Non-repeatable Read모순성(Inconsistency)이라고도 합니다. 동일 트랜잭션에서 동일한 대상을 여러번 읽을 때 그 사이에 수정 또는 삭제가 반영되어 값이 변경됨문제점 서로 다른 트랜잭션은 post의 id가 1인 데이터를 조회 Bob은 post의 title을 ‘Transactions’로 조회하였으나 Alice는 title을 ‘ACID’로 변경 후 커밋 Bob은 post의 title을 ‘Transactions’로 기대하고 조회하였으나 ‘ACID’로 변경된 데이터를 확인IV. Phantom Read 동일 트랜잭션에서 동일한 대상을 여러번 읽을 때 그 사이에 새로운 값(Phantom Tuple)이 삽입되어 값이 변경됨문제점 Bob’s는 post id가 1인 게시물 행과 연결된 모든 post_comment 레코드를 읽습니다. Alice는 post id가 1인 게시물 행과 연결된 새로운 post_comment 레코드를 추가합니다. Alice는 데이터베이스 트랜잭션을 커밋합니다. Bob이 post id의 값이 1인 post_comment 레코드를 다시 읽으면 이 결과 다른버전의 post_comment 집합을 확인하게 됩니다.동시 접근에 대해 이상현상이 생기지 않음을 보장하는 트랜잭션 고립화 수준에 관한 표준 격리 수준 Dirty Read Non-Repeatable Read Phantom Read Read Uncommitted (Level 0) O O O Read Committed (Level 1) X O O Repeatable Read (Level 2) X X O Serializable (Level 3) X X X 문제점을 해결하기 위해위에서 살펴본 문제점을 해결하기 위해 어떠한 방법들이 있을까요?다중 사용자 환경을 지원하는 데이터베이스는 동시성 제어를 위한 여러가지 기법들을 제시하고 있습니다.로킹 (Locking) 기법잠금 기법은 기본적으로 lock 연산과 unlock 연산을 사용합니다. 트랜잭션이 어떤 데이터에 접근하고자 할 때 로킹 수행 로킹이 되어 있는 데이터에는 다른 트랜잭션이 접근할 수 없음 트랜잭션은 로킹이 된 데이터에 대해서만 연산 수행잠금(Locking)은 하나의 트랜잭션이 실행하는 동안 특정 데이터 항목에 대해서 다른 트랜잭션이 동시에 접근하지 못하도록 상호배제(Mutual Exclusive) 기능을 제공하는 기법입니다. 하나의 트랜잭션이 데이터 항목에 대하여 잠금(lock)을 설정하면, 잠금을 설정한 트랜잭션이 해제(unlock)할 때까지 데이터를 독점적으로 사용할 수 있습니다.잠금 연산의 종류잠금 연산은 데이터에 대한 연산의 성격에 따라 공유잠금(Shared lock: S-lock)과 배타잠금(Exclusive lock: X-lock)으로 나눌 수 있습니다. S-lock(공유잠금) 공유잠금을 설정한 트랜잭션은 데이터 항목에 대해 읽기 연산(read)만 가능하다. ex) T1에서 x에 대해 S-lock을 설정했다면, T1은 read(x) 연산만 가능하다. 하나의 데이터 항목에 대해 여러 개의 공유잠금이(S-lock) 가능하다. ex) T1에서 x에 대해 S-lock을 설정한 경우, 동시에 T2에서도 x에 대해 S-lock을 설정할 수 있다. 다른 트랜잭션도 읽기 연산(read) 만을 실행할 수 있다. ex) T1에서 x에 대해 S-lock을 설정했다면, T2에서도 T1이 S-lock(x)을 실행하는 동안 read(x) 연산만 가능하다. X-lock(배타잠금) 배타잠금을 설정한 트랜잭션은 데이터 항목에 대해서 읽기 연산(read)과 쓰기 연산(write) 모두 가능하다. ex) T1에서 x에 대해 S-lock을 설정했다면, T1은 read(x) 연산과 write(x) 연산 모두 가능하다.하나의 데이터 항목에 대해서는 하나의 배타잠금(X-lock)만 가능하다. 동시에 여러 개의 배타잠금은 불가능하다. ex) T1에서 x에 대해 X-lock을 설정했다면, T1에서 unlock(x)를 하기 전까지 T2에서 x에 대해 X-lock을 설정할 수 없다. 다른 트랜잭션은 읽기 연산(read)와 쓰기 연산(write) 모두 불가능하다. ex) T1에서 x에 대해 X-lock을 설정했다면, T2에서는 T1에서 unlock(x)를 하기 전까지 read(x), write(x) 연산이 모두 불가능하다. 2단계 로킹 규약(Two-Phase Locking Protocol) Lock과 Unlock이 동시에 이루어지면 일관성이 보장되지 않으므로 Lock만 가능한 단계와 Unlock만 가능한 단계를 구분 확장단계: 새로운 Lock은 가능하고 Unlock은 불가능하다. 축소단계: Unlock 은 가능하고 새로운 Lock은 불가능하다. 직렬가능성을 보장한다. 교착상태가 발생할 수 있다타임스탬프(Time Stamp) 데이터에 접근하는 시간을 미리 정하여서 정해진 시간(Time Stamp)의 순서대로 데이터에 접근 하여 수행 직렬가능성을 보장한다. 교착상태가 발생하지 않는다. 연쇄복귀(Cascading Rollback)를 초래할 수 있음낙관적 병행제어(Optimistic Concurrency Control) 트랜잭션 수행 동안은 어떠한 검사도 하지 않고, 트랜잭션 종료 시에 일괄적으로 검사 트랜잭션 수행 동안 그 트랜잭션을 위해 유지되는 데이터 항목들의 지역 사본에 대해서만 갱신 트랜잭션 종료 시에 동시성을 위한 트랜잭션 직렬화가 검증되면 일시에 DB로 반영다중 버전 병행제어(Multi-version, Concurrency Control) or ( MVCC ) 여러 버전의 타임스탬프를 비교하여 스케줄상 직렬가능성이 보장되는 타임스탬프를 선택 충돌이 발생할 경우 복귀 수행. 연쇄 복귀 발생 가능성 references https://victorydntmd.tistory.com/129 https://junhyunny.github.io/information/transcation-isolation/ https://medium.com/pocs/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4-%EA%B8%B0%EB%B2%95-%EC%9E%A0%EA%B8%88-locking-%EA%B8%B0%EB%B2%95-319bd0e6a68a https://itwiki.kr/w/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EB%B3%91%ED%96%89%EC%A0%9C%EC%96%B4 https://en.wikipedia.org/wiki/Concurrency_control#Database_transaction_and_the_ACID_rules " }, { "title": "Transcation이란?", "url": "/posts/transaction/", "categories": "DataBase", "tags": "DataBase", "date": "2021-12-22 00:00:00 +0900", "snippet": "트랜잭션이란?완결성 있게 처리되어야 하는 하나의 논리적인 작업단위를 말합니다.이 논리적 작업 단위 내에는 여러동작 ( 질의, query ) 들이 존재하며 이들은 모두 실행되거나 모두 실행되지 않아야 합니다. 만약 작업단위가 중간에 실행이 중단 됐을 경우, 처음부터 다시 실행하는 rollback을 수행하고, 성공한다면 commit 하여 현재 데이터를 확정짓습니다.즉, 한번 질의가 실행되면 질의가 모두 수행되거나 모두 수행되지 않는 작업수행의 논리적 단위 입니다.특성트랜잭션은 아래와 같은 4가지 특성이 있습니다.4가지 특성의 앞 글자만 따서 ACID 특성이라 칭합니다. 원자성 ( Atomicity ) 트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장하는 것을 말합니다. 즉, All or Noting의 개념으로서 작업 단위를 일부분만 실행하지 않는다는 것을 의미합니다. 일관성 ( Consistency ) 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미합니다. 여기서 말하는 일관성이란, DB의 상태 ( ex. 기본키 외래키 제약과 같은 무결성 제약, DataType 등 )가 일관되는 것을 뜻합니다. 독립성 ( Isolation ) 트랜잭션 수행시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장하는 것을 말합니다. 즉, 트랜잭션끼리는 서로를 간섭할 수 없습니다. 지속성 ( Durability ) 성공적으로 수행된 트랜잭션은 영원히 반영이 되는 것을 말합니다. commit을 하면 현재 상태는 영원히 보장됩니다. references https://junhyunny.github.io/information/transcation-acid/ https://victorydntmd.tistory.com/129 https://ko.wikipedia.org/wiki/ACID " }, { "title": "(MyBatis) Mapper등록", "url": "/posts/injectMapper/", "categories": "Java, MyBatis", "tags": "Java, MyBatis", "date": "2021-12-17 00:00:00 +0900", "snippet": "mybatis-spring 프레임워크를 사용할 때 mapper를 springContext에 주입하는 방법으로 크게 2가지가 있습니다 Mapper 수동 등록 Mapper 스캔을 이용한 자동 등록두가지 방법을 알아보겠습니다. 목차 Mapper 수동 등록하기 XML설정 사용 Mapper 스캔 I. mybatis:scan 엘리먼트 사용 base-package annotation marker-interface II. 스프링 XML파일을 사용해서 MapperScannerConfigurer를 등록 Mapper 수동 등록하기 XML설정 사용 자바설정 사용Mapper 수동등록은 XML을 이용한 Mapper 등록을 알아보겠습니다.XML설정 사용매퍼는 다음처럼 XML설정파일에 MapperFactoryBean을 두는 것으로 스프링에 등록됩니다.&amp;lt;!--1. Mapper 등록--&amp;gt;&amp;lt;bean id=&quot;userMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&amp;gt; &amp;lt;property name=&quot;mapperInterface&quot; value=&quot;com.gil.mybatis.mapper.MyBatisMapper&quot; /&amp;gt; &amp;lt;property name=&quot;sqlSessionTemplate&quot; ref=&quot;sqlSessionTemplate&quot; /&amp;gt;&amp;lt;/bean&amp;gt;Mapper 스캔Mybatis는 스프링과 같이 사용 할 때 Dao(Mapper) 를 빈에 주입할 수 있는 다양한 방법을 제공합니다. &amp;lt;mybatis:scan/&amp;gt; 엘리먼트 사용 @MapperScan 애노테이션 사용 스프링 XML파일을 사용해서 MapperScannerConfigurer를 등록2번 방법은 1번방법과 xml방식 클래스방식의 차이만 있을 뿐 같은 기능이기 때문에 따로 다루지 않겠습니다.I. mybatis:scan 엘리먼트 사용기본적으로 제일 편리하고 사용하기 쉬운 방법입니다.&amp;lt;mybatis:scan/&amp;gt; 은 다음과 같은 속성을 가지고 있습니다. base-package ( required ) annotation marker-interface factory-ref template-ref default-scope lazy-initialization mapper-factory-bean-class name-generator이 글에서는 base-package annotation marker-interface를 알아보겠습니다.base-packagemapper를 주입시켜줄 package를 지정합니다.&amp;lt;mybatis:scan base-package=&quot;com.gil.mybatis.mapper&quot;/&amp;gt;해당 패키지에 아래에 있는 모든 interface들을 mapper로 등록해 줍니다.annotationmapper를 검색할 annotation을 등록할 수 있습니다.&amp;lt;mybatis:scan/&amp;gt; 설정&amp;lt;mybatis:scan base-package=&quot;com.gil.mybatis.mapper&quot; annotation=&quot;com.gil.utils.GilMapper&quot; /&amp;gt;mapper를 명시해줄 annotation@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface GilMapper{}&amp;lt;mybatis:scan/&amp;gt; 엘리먼트에 annotation 속성을 추가하여 basePackage 내의 mapper들을 필요에 따라 필터링 할 수 있습니다.2개의 mapper가 basePackage 내에 만들어져 있습니다.@GilMapperpublic interface MyBatisMapper { MybatisVo requestUser();}public interface MyBatisMapper2 { MybatisVo requestUser();}위 코드와 같이 둘 중 하나의 Mapper에게 어노테이션을 부여하였습니다.테스트 코드@Test@DisplayName(&quot;Mapper 주입 테스트&quot;)public void mapperInjectTest(){ assertDoesNotThrow(() -&amp;gt; { MyBatisMapper myBatisMapper1 = context.getBean(MyBatisMapper.class); }, &quot;MyBatisMapper1 은 null 입니다.&quot;); assertDoesNotThrow(() -&amp;gt; { MyBatisMapper2 myBatisMapper2 = context.getBean(MyBatisMapper2.class); }, &quot;MyBatisMapper2 은 null 입니다.&quot;);}위 두 mapper인터페이스 중 하나의 mapper에만 어노테이션을 부여하여 원하는 의도대로 mapper스캔이 이루어 졌는지 assertDoesNotThrow메소드를 이용하여 context에 등록되지 않았다면 오류메세지가 출력되도록 테스트코드를 작성하였습니다.결과예상대로 어노테이션이 입력되지 않은 mapper가 context에 등록되지 않아 NoSuchBeanDefinitionException 을 발생시키는 걸 볼 수 있습니다.marker-interfacemarker-interface 프로퍼티는 검색할 상위 인터페이스를 지정할 수 있습니다.&amp;lt;mybatis:scan/&amp;gt; 설정&amp;lt;mybatis:scan base-package=&quot;com.gil.mybatis.mapper&quot; marker-interface=&quot;com.gil.utils.BaseGilMapper&quot; /&amp;gt;상위 인터페이스public interface BaseGilMapper { MybatisVo requestUser();}상위 인터페이스를 상속받은 mapperpublic interface MyBatisMapper extends BaseGilMapper {}위와 같이 marker-interface로 설정해준 상위 인터페이스를 상속받은 mapper 인터페이스만 context에 등록 되게 됩니다. 동시에 상위 인터페이스의 메소드를 사용함으로써 자주 사용하는 기능들을 매번 작성해야하는 수고를 덜 수 있습니다.MyBatisMapper를 namespace로 가지는 xml&amp;lt;mapper namespace=&quot;com.gil.mybatis.mapper.MyBatisMapper&quot;&amp;gt; &amp;lt;select id=&quot;requestUser&quot; resultType=&quot;mybatisVo&quot;&amp;gt; select * from tb_user limit 1 &amp;lt;/select&amp;gt;&amp;lt;/mapper&amp;gt;테스트 코드@Test@DisplayName(&quot;Mapper 주입 테스트&quot;)public void mapperInjectTest(){ assertDoesNotThrow(() -&amp;gt; { MyBatisMapper myBatisMapper1 = context.getBean(MyBatisMapper.class); }, &quot;MyBatisMapper1 은 null 입니다.&quot;); assertDoesNotThrow(() -&amp;gt; { MyBatisMapper2 myBatisMapper2 = context.getBean(MyBatisMapper2.class); }, &quot;MyBatisMapper2 은 null 입니다.&quot;);}테스트 코드는 위의 annotation 프로퍼티를 이용한 테스트와 같은 조건으로 MyBatisMapper 인터페이스만 상위 인터페이스 상속을 받아 진행하였습니다.결과상위 인터페이스를 상속받은 mapper인터페이스 만 context에 주입되는 것을 확인 할 수 있습니다.또 한가지저는 marker-interface 를 이용한 상속 방법이 과연 xml매퍼 파일로 등록된 쿼리문을 실행시킬 수 있을지 궁금하였습니다.테스트 코드marker-interface를 상속받은 MyBatisMapper의 requestUser 메소드를 실행하는 service 클래스입니다.@Servicepublic class MyBatisServiceImpl implements MyBatisService { private final MyBatisMapper myBatisMapper; public MyBatisServiceImpl(MyBatisMapper myBatisMapper) { this.myBatisMapper = myBatisMapper; } @Override public MybatisVo requestTest1() { return myBatisMapper.requestUser(); }}@Test@DisplayName(&quot;유저 조회 테스트&quot;)public void userSelectTest(){ MybatisVo mybatisVo = myBatisService.requestTest1(); System.out.println(&quot;--------------------------------&quot;); System.out.println(&quot;mybatisVo = &quot; + mybatisVo); System.out.println(&quot;--------------------------------&quot;);}결과marker-interface 를 상속받은 메소드도 xml매퍼 파일에 접근이 가능하다는걸 볼 수 있습니다.II. 스프링 XML파일을 사용해서 MapperScannerConfigurer를 등록&amp;lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&amp;gt; &amp;lt;property name=&quot;basePackage&quot; value=&quot;com.gil.mybatis.mapper&quot;/&amp;gt; &amp;lt;property name=&quot;sqlSessionTemplateBeanName&quot; value=&quot;sqlSessionTemplate&quot;/&amp;gt;&amp;lt;/bean&amp;gt;MapperScannerConfigurer을 bean으로 등록해주는 방법으로도 mapper들을 등록할 수 있습니다. Github source https://github.com/fkdl3010/java-and-spring/tree/main/5_mybatis/injectMapper references mybatis-spring 공식홈페이지 https://okky.kr/article/448042 " }, { "title": "Optional", "url": "/posts/optional/", "categories": "Java", "tags": "Java", "date": "2021-11-29 02:00:00 +0900", "snippet": "OptionalOptional는 “존재할 수도 있지만 안 할 수도 있는 객체”, 즉, “null이 될 수도 있는 객체”을 감싸고 있는 일종의 래퍼 클래스입니다. 원소가 없거나 최대 하나 밖에 없는 Collection이나 Stream으로 생각하셔도 좋습니다. 직접 다루기에 위험하고 까다로운 null을 담을 수 있는 특수한 그릇으로 생각하시면 이해가 쉬우실 것 같습니다.Optional 기본 사용법1. Optional 변수 선언하기제네릭을 제공하기 때문에, 변수를 선언할 때 명기한 타입 파라미터에 따라서 감쌀 수 있는 객체의 타입이 결정됩니다.Optional&amp;lt;Order&amp;gt; maybeOrder; // Order 타입의 객체를 감쌀 수 있는 Optional 타입의 변수Optional&amp;lt;Member&amp;gt; optMember; // Member 타입의 객체를 감쌀 수 있는 Optional 타입의 변수Optional&amp;lt;Address&amp;gt; address; // Address 타입의 객체를 감쌀 수 있는 Optional 타입의 변수2. Optional 객체 생성하기 Optional.empty()null을 담고 있는, 한 마디로 비어있는 Optional 객체를 얻어옵니다. 이 비어있는 객체는 Optional 내부적으로 미리 생성해놓은 싱글턴 인스턴스입니다.Optional&amp;lt;Member&amp;gt; maybeMember = Optional.empty(); Optional.of(value)null이 아닌 객체를 담고 있는 Optional 객체를 생성합니다. null이 넘어올 경우, NPE를 던지기 때문에 주의해서 사용해야 합니다.Optional&amp;lt;Member&amp;gt; maybeMember = Optional.of(aMember); Optional.ofNullable(value)null인지 아닌지 확신할 수 없는 객체를 담고 있는 Optional 객체를 생성합니다. Optional.empty()와 Optional.ofNullable(value)를 합쳐놓은 메소드라고 생각하시면 됩니다. null이 넘어올 경우, NPE를 던지지 않고 Optional.empty()와 동일하게 비어 있는 Optional 객체를 얻어옵니다. 해당 객체가 null인지 아닌지 자신이 없는 상황에서는 이 메소드를 사용하셔야 합니다.Optional&amp;lt;Member&amp;gt; maybeMember = Optional.ofNullable(aMember);Optional&amp;lt;Member&amp;gt; maybeNotMember = Optional.ofNullable(null);3. Optional이 담고 있는 객체 접근하기Optional 클래스는 담고 있는 객체를 꺼내오기 위해서 다양한 인스턴스 메소드를 제공합니다. 아래 메소드들은 모두 Optional이 담고 있는 객체가 존재할 경우 동일하게 해당 값을 반환합니다. 반면에 Optional이 비어있는 경우(즉, null을 담고 있는 경우), 다르게 작동합니다. 따라서 비어있는 Optional에 대해서 다르게 작동하는 부분만 설명드리겠습니다. get()비어있는 Optional 객체에 대해서, NoSuchElementException을 던집니다. orElse(T other)비어있는 Optional 객체에 대해서, 넘어온 인자를 반환합니다. orElseGet(Supplier&amp;lt;? extends T&amp;gt; other)비어있는 Optional 객체에 대해서, 넘어온 함수형 인자를 통해 생성된 객체를 반환합니다. orElse(T other)의 게으른 버전이라고 보시면 됩니다. 비어있는 경우에만 함수가 호출되기 때문에 orElse(T other) 대비 성능상 이점을 기대할 수 있습니다. orElseThrow(Supplier&amp;lt;? extends X&amp;gt; exceptionSupplier)비어있는 Optional 객체에 대해서, 넘어온 함수형 인자를 통해 생성된 예외를 던집니다.Api return type method Description static &amp;lt;T&amp;gt; Optional&amp;lt;T&amp;gt; empty() 빈 Optional 객체를 반환한다. Optional&amp;lt;T&amp;gt; filter(Predicate&amp;lt;? super T&amp;gt; predicate) 값이 존재하고 값이 주어진 predicate 의 조건을 일치하는 Optional을 반환한다 아니면 빈 Optional을 반환한다. &amp;lt;U&amp;gt; Optional &amp;lt;U&amp;gt; flatMap(Function&amp;lt;? super T,? extends Optional&amp;lt;? extends U» mapper) 값이 존재하면 값을 적용한 뒤 optional 객체로 반환한다. T get() 반환되는 값이 존재하면 값을 반환하고 아니면 NoSuchElementException 를 발생시킨다. void ifPresent(Consumer&amp;lt;? super T&amp;gt; action) 반환되는 값이 존재하면 consumer를 수행하고 아니면 아무것도 하지않는다. void ifPresentOrElse(Consumer&amp;lt;? super T&amp;gt; action, Runnable emptyAction) 반환되는 값이 존재하면 consumer를 수행하고 아니면 주어진 Runnable 을 수행한다. boolean isEmpty() 값이 존재하지않으면 true 아니면 false boolean isPresent() 값이 존재하면 true 아니면 false &amp;lt;U&amp;gt; Optional &amp;lt;U&amp;gt; map(Function&amp;lt;? super T,? extends U&amp;gt; mapper) 값이 존재하면 주어진 function에 의해 적용된 값을 포함하는 Optional을 반환한다, 아니면 빈 Optional을 반환한다. static &amp;lt;T&amp;gt; Optional&amp;lt;T&amp;gt; of(T value) null 이 아닌 Optional을 반환한다. static &amp;lt;T&amp;gt; Optional&amp;lt;T&amp;gt; ofNullable(T value) Optional을 반환한다 null이면 빈 Optional을 반환한다. Optional&amp;lt;T&amp;gt; or(Supplier&amp;lt;? extends Optional&amp;lt;? extends T» supplier) Optional이 empty인 경우에 다른 Optional을 반환 T orElse(T other) Optional의 값을 반환하되 null이면 인자를 리턴한다. T orElseGet(Supplier&amp;lt;? extends T&amp;gt; supplier) Optional의 값을 반환하되 null이면 Supplier에 의해 제공되는 값을 반환한다. T orElseThrow() Optional의 값을 반환하되 null이면 NoSuchElementException을 발생시킨다. &amp;lt;X extends Throwable&amp;gt;T orElseThrow(Supplier&amp;lt;? extends X&amp;gt; exceptionSupplier) Optional의 값을 반환하되 null이면 Supplier에 의해 제공되는 Exception을 발생시킨다. Stream&amp;lt;T&amp;gt; stream() 값이 있으면 해당 값만 포함하는 스트림을 반환하고, 그렇지 않으면 빈스트림을 반환한다. etc그 밖에도 OptionalInt, OptionalDouble, OptionalInt, OptionalLong 도 있습니다.public static void main(String[] args) { OptionalInt opt1 = OptionalInt.empty(); OptionalInt opt2 = OptionalInt.of(0); System.out.println(&quot;opt1.isEmpty() = &quot; + opt1.isEmpty()); // true System.out.println(&quot;opt2.isEmpty() = &quot; + opt2.isEmpty()); // false System.out.println(&quot;opt2.equals(opt1) = &quot; + opt2.equals(opt1)); // false} Github source https://github.com/fkdl3010/java-and-spring/tree/main/1_java/optional references https://www.daleseo.com/java8-optional-after/ https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html " }, { "title": "doRealMethod", "url": "/posts/doRealMethod/", "categories": "Java, Junit", "tags": "Mock, Junit, Java", "date": "2021-08-27 02:00:00 +0900", "snippet": "Mockito 프레임워크가 제공하는 Stub 기반의 테스트 방법 중 doRealMethod()를 알아보겠습니다.doRealMethod() 란?Mock 실행 객체 참조를 사용하여 메서드를 참조할 때 java는 해당 메서드에 대한 호출을 전혀 하지 않으며, 지정된 값이 없으면 모의 실행 값을 반환하거나 null을 찾습니다. 하지만 만약 우리가 그것을 재정의하고 java가 모의 객체 참조를 사용하여 실제 메소드를 호출하기를 원한다면, 이 메소드를 사용할 수 있습니다. 출처: https://javasearch.buggybread.com/InterviewQuestions/questionSearch.php?searchOption=question&amp;amp;keyword=3813테스트 코드를 통해 알아보겠습니다.Study.class@Getter@Setter@NoArgsConstructorpublic class Study { public void doRealMethodTest(){ System.out.println(&quot;테스트입니다&quot;); }}StudyServiceTest.class@ExtendWith(MockitoExtension.class)class StudyServiceTest { @Mock Study mockStudy; @Test void createDoRealMethodTest(){ mockStudy.doRealMethodTest(); }}Mock 으로 생성한 객체의 메소드를 실행하면 어떻게 될까요?Mock 의 개념을 이해하지 못했다면 해당 메소드가 실행될것이라고 예상할 수도 있습니다.결과하지만 Mock 객체의 정의는 다음과 같습니다. 진짜 객체와 비슷하게 동작하지만 프로그래머가 직접 그 객체의 행동을 관리하는 객체.그리고모든 Mock 객체의 행동은 다음과 같습니다. Null을 리턴한다. (Optional 타입은 Optional.empty 리턴) Primitive 타입은 기본 Primitive 값. 콜렉션은 비어있는 콜렉션. Void 메소드는 예외를 던지지 않고 아무런 일도 발생하지 않는다.이러한 이유로 Mock으로 생성한 객체의 메소드를 호출 해도 자바는 해당 객체의 메소드 호출을 하지 않습니다.doRealMethod() 메소드는 이러한 문제점을 해결해 줍니다.doRealMethod() 사용StudyServiceTest.class@ExtendWith(MockitoExtension.class)class StudyServiceTest { @Mock Study mockStudy; @Test void createDoRealMethodTest( ){ Mockito.doCallRealMethod().when(mockStudy).doRealMethodTest(); mockStudy.doRealMethodTest(); }}결과doRealMethod()를 이용하여 Mock 객체로 생성한 객체의 실제 메소드를 호출하는 모습을 볼 수 있습니다." } ]
